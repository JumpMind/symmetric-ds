<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"
    default-lazy-init="true">

    <bean id="transportManager" class="org.jumpmind.symmetric.transport.TransportManagerFactoryBean"
        scope="singleton">
        <property name="transport" value="${symmetric.transport.type}" />
        <property name="runtimeConfiguration" ref="runtimeConfiguration" />
        <property name="nodeService" ref="nodeService" />
        <property name="httpTimeout" value="${symmetric.runtime.http.timeout.ms}" />
        <property name="useCompression" value="${symmetric.runtime.http.compression}" />
    </bean>

    <bean id="bootstrapService" class="org.jumpmind.symmetric.service.impl.BootstrapService"
        scope="singleton">
        <property name="triggerPrefix" value="${symmetric.runtime.trigger.prefix}" />
        <property name="tablePrefix" value="${sync.table.prefix}" />
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="dbDialect" ref="dbDialect" />
        <property name="parameterService" ref="parameterService" />
        <property name="nodeService" ref="nodeService" />
        <property name="transportManager" ref="transportManager" />
        <property name="dataLoaderService" ref="dataLoaderService" />
        <property name="configurationService" ref="configurationService" />
        <property name="runtimeConfiguration" ref="runtimeConfiguration" />
        <property name="dataService" ref="dataService" />
        <property name="upgradeService" ref="upgradeService" />
        <property name="clusterService" ref="clusterService" />
        <property name="autoConfigureDatabase" value="${symmetric.auto.config.database}" />
        <property name="autoUpgrade" value="${symmetric.auto.upgrade}" />
    </bean>

    <bean id="parameterService" class="org.jumpmind.symmetric.service.impl.ParameterService"
        scope="singleton">
        <property name="tablePrefix" value="${sync.table.prefix}" />
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="defaultGlobalParameters" ref="defaultGlobalParameters" />
        <property name="runtimeConfiguration" ref="runtimeConfiguration" />
    </bean>

    <bean id="configurationService" class="org.jumpmind.symmetric.service.impl.ConfigurationService"
        scope="singleton">
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="dbDialect" ref="dbDialect" />
        <property name="runtimeConfiguration" ref="runtimeConfiguration" />
        <property name="rootConfigChannelTableNames">
            <list>
                <value>${sync.table.prefix}_node_group</value>
                <value>${sync.table.prefix}_node_group_link</value>
                <value>${sync.table.prefix}_node</value>
                <value>${sync.table.prefix}_node_security</value>
                <value>${sync.table.prefix}_global_parameter</value>
                <value>${sync.table.prefix}_channel</value>
                <value>${sync.table.prefix}_node_channel_ctl</value>
                <value>${sync.table.prefix}_trigger</value>
            </list>
        </property>
        <property name="rootConfigChannelInitialLoadSelect">
            <map>
                <entry key="${sync.table.prefix}_node_group">
                    <value>
                        node_group_id = '$(groupId)' or node_group_id in (select
                        source_node_group_id from ${sync.table.prefix}_node_group_link where
                        target_node_group_id = '$(groupId)') or node_group_id in (select
                        target_node_group_id from ${sync.table.prefix}_node_group_link where
                        source_node_group_id = '$(groupId)')
                    </value>
                </entry>
                <entry key="${sync.table.prefix}_node_group_link">
                    <value>
                        source_node_group_id = '$(groupId)' or target_node_group_id = '$(groupId)'
                    </value>
                </entry>
                <entry key="${sync.table.prefix}_node">
                    <value>
                        node_id = '$(nodeId)' or node_group_id in (select source_node_group_id from
                        ${sync.table.prefix}_node_group_link where target_node_group_id =
                        '$(groupId)') or node_group_id in (select target_node_group_id from
                        ${sync.table.prefix}_node_group_link where source_node_group_id =
                        '$(groupId)')
                    </value>
                </entry>
                <entry key="${sync.table.prefix}_node_security">
                    <value>
                        node_id = '$(nodeId)' or node_id in (select s.node_id from
                        ${sync.table.prefix}_node s inner join ${sync.table.prefix}_node_group_link
                        l on s.node_group_id = l.source_node_group_id where l.target_node_group_id =
                        '$(groupId)') or node_id in (select s.node_id from ${sync.table.prefix}_node
                        s inner join ${sync.table.prefix}_node_group_link l on s.node_group_id =
                        l.target_node_group_id where l.source_node_group_id = '$(groupId)')
                    </value>
                </entry>
                <entry key="${sync.table.prefix}_global_parameter">
                    <value>node_group_id = '$(groupId)'</value>
                </entry>
                <entry key="${sync.table.prefix}_channel">
                    <value>
                        channel_id in (select channel_id from ${sync.table.prefix}_trigger where
                        source_node_group_id = '$(groupId)' or target_node_group_id = '$(groupId)')
                        or channel_id = 'reload'
                    </value>
                </entry>
                <entry key="${sync.table.prefix}_node_channel_ctl">
                    <value>node_id = '$(nodeId)'</value>
                </entry>
                <entry key="${sync.table.prefix}_trigger">
                    <value>
                        source_node_group_id = '$(groupId)' or target_node_group_id = '$(groupId)'
                    </value>
                </entry>
            </map>
        </property>
        <property name="nodeConfigChannelTableNames">
            <list>
                <value>${sync.table.prefix}_node</value>
            </list>
        </property>
        <property name="inactivateTriggerHistorySql">
            <value>
                update ${sync.table.prefix}_trigger_hist set inactive_time = current_timestamp where
                trigger_hist_id=?
            </value>
        </property>
        <property name="selectDataEventActionsByIdSql">
            <value>
                select data_event_action from ${sync.table.prefix}_node_group_link where
                source_node_group_id = ? and target_node_group_id = ?
            </value>
        </property>
        <property name="selectChannelsSql">
            <value>
                select c.channel_id, nc.node_id, nc.ignore_enabled, nc.suspend_enabled,
                c.processing_order, c.max_batch_size, c.enabled, c.max_batch_to_send from ${sync.table.prefix}_channel c
                inner join ${sync.table.prefix}_node_identity n on 1 = 1 left outer join
                ${sync.table.prefix}_node_channel_ctl nc on c.channel_id = nc.channel_id and
                n.node_id = nc.node_id order by c.processing_order asc
            </value>
        </property>
        <property name="selectGroupTriggersSql">
            <value>
                select * from ${sync.table.prefix}_trigger where source_node_group_id = ? order by
                channel_id
            </value>
        </property>
        <property name="activeTriggersForSourceNodeGroupSql">
            <value>
                select * from ${sync.table.prefix}_trigger where source_node_group_id = ? and
                inactive_time is null
            </value>
        </property>
        <property name="activeTriggersForReloadSql">
            <value>
                select * from ${sync.table.prefix}_trigger where source_node_group_id = ? and
                target_node_group_id = ? and channel_id != ? and inactive_time is null order by
                initial_load_order
            </value>
        </property>
        <property name="inactiveTriggersForSourceNodeGroupSql">
            <value>
                select * from ${sync.table.prefix}_trigger t inner join
                ${sync.table.prefix}_trigger_hist h on t.trigger_id=h.trigger_id where
                h.inactive_time is not null and t.source_node_group_id = ? and t.inactive_time is
                not null
            </value>
        </property>
        <property name="insertTriggerSql">
            <value>
                insert into ${sync.table.prefix}_trigger (source_table_name, source_node_group_id,
                target_node_group_id, channel_id, source_schema_name, sync_on_update,
                sync_on_insert, sync_on_delete, initial_load_order, initial_load_select,
                last_updated_by, last_updated_time, create_time) values (?, ?, ?, ?, null, 0, 0, 0,
                ?, ?, 'system', current_timestamp, current_timestamp)
            </value>
        </property>
        <property name="groupsLinksSql">
            <value>
                select source_node_group_id, target_node_group_id, data_event_action from
                ${sync.table.prefix}_node_group_link
            </value>
        </property>
        <property name="groupsLinksForSql">
            <value>
                select source_node_group_id, target_node_group_id, data_event_action from
                ${sync.table.prefix}_node_group_link where source_node_group_id = ?
            </value>
        </property>
        <property name="insertChannelSql">
            <value>
                insert into ${sync.table.prefix}_channel values(?, ?, ?, ?, 1, 'System-generated
                channel. Do not remove.')
            </value>
        </property>
        <property name="allTriggerHistSql">
            <value>
                select
                trigger_hist_id,trigger_id,source_table_name,table_hash,create_time,pk_column_names,column_names,last_trigger_build_reason,name_for_delete_trigger,name_for_insert_trigger,name_for_update_trigger,source_schema_name
                from ${sync.table.prefix}_trigger_hist
            </value>
        </property>
        <property name="latestTriggerHistSql">
            <value>
                select
                trigger_hist_id,trigger_id,source_table_name,table_hash,create_time,pk_column_names,column_names,last_trigger_build_reason,name_for_delete_trigger,name_for_insert_trigger,name_for_update_trigger,source_schema_name
                from ${sync.table.prefix}_trigger_hist where trigger_hist_id = (select
                max(trigger_hist_id) from ${sync.table.prefix}_trigger_hist where trigger_id=?)
            </value>
        </property>
        <property name="triggerHistSql">
            <value>
                select
                trigger_hist_id,trigger_id,source_table_name,table_hash,create_time,pk_column_names,column_names,last_trigger_build_reason,name_for_delete_trigger,name_for_insert_trigger,name_for_update_trigger,source_schema_name
                from ${sync.table.prefix}_trigger_hist where trigger_hist_id = ?
            </value>
        </property>
        <property name="insertTriggerHistorySql">
            <value>
                insert into ${sync.table.prefix}_trigger_hist
                (trigger_id,source_table_name,table_hash,create_time,column_names,pk_column_names,last_trigger_build_reason,name_for_delete_trigger,name_for_insert_trigger,name_for_update_trigger,source_schema_name)
                values(?,?,?,?,?,?,?,?,?,?,?)
            </value>
        </property>
        <property name="selectTriggerSql">
            <value>
                select * from ${sync.table.prefix}_trigger where source_table_name = ? and
                source_node_group_id = ?
            </value>
        </property>
        <property name="selectTriggerTargetSql">
            <value>
                select * from ${sync.table.prefix}_trigger where source_table_name = ? and
                target_node_group_id = ? and channel_id = ? and source_node_group_id = ?
            </value>
        </property>
        <property name="selectTriggerByIdSql">
            <value>select * from ${sync.table.prefix}_trigger where trigger_id = ?</value>
        </property>
    </bean>

    <bean id="outgoingBatchService" class="org.jumpmind.symmetric.service.impl.OutgoingBatchService"
        scope="singleton">
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="batchSizePeekAhead" value="${symmetric.runtime.outgoing.batches.peek.ahead.window.after.max.size}"/>
        <property name="runtimeConfiguration" ref="runtimeConfiguration" />
        <property name="configurationService" ref="configurationService" />
        <property name="nodeService" ref="nodeService" />
        <property name="historyService" ref="outgoingBatchHistoryService" />
        <property name="dbDialect" ref="dbDialect" />
        <property name="outgoingBatchQueryTemplate">
            <bean class="org.springframework.jdbc.core.JdbcTemplate">
                <property name="dataSource" ref="dataSource" />
                <property name="queryTimeout" value="${db.sql.query.timeout.seconds}" />
            </bean>
        </property>
        <property name="initialLoadStatusSql">
            <value>
                select status from ${sync.table.prefix}_outgoing_batch where channel_id='reload' and
                node_id=?
            </value>
        </property>

        <property name="selectEventsToBatchSql">
            <value>
                select transaction_id, data_id from ${sync.table.prefix}_data_event where batched =
                0 and node_id = ? and channel_id=? order by data_id asc
            </value>
        </property>
        <property name="createBatchSql">
            <value>
                insert into ${sync.table.prefix}_outgoing_batch (batch_id, node_id, channel_id,
                status, batch_type, create_time) values (null, ?, ?, ?, ?, current_timestamp)
            </value>
        </property>
        <property name="updateBatchedEventsSql">
            <value>
                update ${sync.table.prefix}_data_event set batch_id = ?, batched = 1 where node_id =
                ? and data_id = ?
            </value>
        </property>
        <property name="selectOutgoingBatchSql">
            <value>
                select b.batch_id, b.node_id, b.channel_id, b.status, b.batch_type, b.create_time
                from ${sync.table.prefix}_outgoing_batch b left join (select node_id, channel_id
                from ${sync.table.prefix}_outgoing_batch where status = 'ER') e on e.node_id =
                b.node_id and e.channel_id = b.channel_id where b.node_id = ? and b.status in ('NE',
                'SE', 'ER') order by case when e.channel_id is null then 1 else 2 end, b.batch_id
            </value>
        </property>
        <property name="selectOutgoingBatchRangeSql">
            <value>
                select batch_id, node_id, channel_id, status, batch_type, create_time from
                ${sync.table.prefix}_outgoing_batch where batch_id between ? and ? order by batch_id
            </value>
        </property>
        <property name="selectOutgoingBatchErrorsSql">
            <value>
                select batch_id, node_id, channel_id, status, batch_type, create_time from
                ${sync.table.prefix}_outgoing_batch where status = 'ER' order by batch_id
            </value>
        </property>
        <property name="changeBatchStatusSql">
            <value>update ${sync.table.prefix}_outgoing_batch set status=? where batch_id=?</value>
        </property>
    </bean>

    <bean id="dataExtractorService"
        class="org.jumpmind.symmetric.service.impl.DataExtractorService">
        <property name="outgoingBatchService" ref="outgoingBatchService" />
        <property name="configurationService" ref="configurationService" />
        <property name="dbDialect" ref="dbDialect" />
        <property name="tablePrefix" value="${sync.table.prefix}" />
        <property name="context" ref="extractorContext" />
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="selectEventDataToExtractSql">
            <value>
                select d.data_id, d.table_name, d.event_type, d.row_data, d.pk_data, e.batch_id,
                d.create_time, d.trigger_hist_id from ${sync.table.prefix}_data d inner join
                ${sync.table.prefix}_data_event e on d.data_id = e.data_id where e.node_id = ? and
                e.batch_id = ? order by d.data_id asc
            </value>
        </property>
    </bean>

    <bean id="dataService" class="org.jumpmind.symmetric.service.impl.DataService"
        scope="singleton">
        <property name="deleteFirstForReload"
            value="${symmetric.runtime.initial.load.delete.first}" />
        <property name="createFirstForReload"
            value="${symmetric.runtime.initial.load.create.first}" />
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="outgoingBatchService" ref="outgoingBatchService" />
        <property name="configurationService" ref="configurationService" />
        <property name="runtimeConfiguration" ref="runtimeConfiguration" />
        <property name="nodeService" ref="nodeService" />
        <property name="purgeService" ref="purgeService" />
        <property name="dbDialect" ref="dbDialect" />
        <property name="tablePrefix" value="${sync.table.prefix}" />
        <property name="insertIntoDataSql">
            <value>
                insert into ${sync.table.prefix}_data (data_id, table_name, event_type, row_data,
                pk_data, trigger_hist_id, create_time) values(null, ?, ?, ?, ?, ?,
                current_timestamp)
            </value>
        </property>
        <property name="insertIntoDataEventSql">
            <value>
                insert into ${sync.table.prefix}_data_event (data_id, node_id, channel_id,
                transaction_id, batch_id, batched) values(?, ?, ?, ?, ?, ?)
            </value>
        </property>
    </bean>

    <bean id="pushService" class="org.jumpmind.symmetric.service.impl.PushService">
        <property name="extractor" ref="dataExtractorService" />
        <property name="transportManager" ref="transportManager" />
        <property name="ackService" ref="acknowledgeService" />
        <property name="nodeService" ref="nodeService" />
    </bean>

    <bean id="pullService" class="org.jumpmind.symmetric.service.impl.PullService">
        <property name="dataLoaderService" ref="dataLoaderService" />
        <property name="nodeService" ref="nodeService" />
    </bean>

    <bean id="dataLoaderService" class="org.jumpmind.symmetric.service.impl.DataLoaderService"
        scope="singleton">
        <property name="numberOfStatusSendRetries" value="${symmetric.runtime.num.of.ack.retries}" />
        <property name="timeBetweenStatusSendRetriesMs"
            value="${symmetric.runtime.time.between.ack.retries.ms}" />
        <property name="dbDialect" ref="dbDialect" />
        <property name="transactionTemplate" ref="transactionTemplate" />
        <property name="transportManager" ref="transportManager" />
        <property name="incomingBatchService" ref="incomingBatchService" />
        <property name="nodeService" ref="nodeService" />
    </bean>

    <bean id="dataLoader" class="org.jumpmind.symmetric.load.csv.CsvLoader" scope="prototype">
        <property name="dbDialect" ref="dbDialect" />
        <property name="jdbcTemplate" ref="dataLoaderTemplate" />
        <property name="configurationService" ref="configurationService" />
        <property name="nodeService" ref="nodeService" />
        <property name="enableFallbackInsert" value="true" />
        <property name="enableFallbackUpdate" value="true" />
        <property name="allowMissingDelete" value="true" />
    </bean>

    <bean id="incomingBatchService" class="org.jumpmind.symmetric.service.impl.IncomingBatchService"
        scope="singleton">
        <property name="skipDuplicateBatches"
            value="${symmetric.runtime.incoming.batches.skip.duplicates}" />
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="dbDialect" ref="dbDialect" />
        <property name="findIncomingBatchSql">
            <value>
                select batch_id, node_id, status, create_time from
                ${sync.table.prefix}_incoming_batch where batch_id = ? and node_id = ?
            </value>
        </property>
        <property name="findIncomingBatchErrorsSql">
            <value>
                select batch_id, node_id, status, create_time from
                ${sync.table.prefix}_incoming_batch where status = 'ER' order by batch_id
            </value>
        </property>
        <property name="findIncomingBatchHistorySql">
            <value>
                select batch_id, node_id, status, start_time, end_time, failed_row_number,
                byte_count, network_millis, filter_millis, database_millis,
                statement_count, fallback_insert_count, fallback_update_count, missing_delete_count
                from ${sync.table.prefix}_incoming_batch_hist where batch_id = ? and node_id = ?
                order by start_time
            </value>
        </property>
        <property name="insertIncomingBatchSql">
            <value>
                insert into ${sync.table.prefix}_incoming_batch (batch_id, node_id, status,
                create_time) values (?, ?, ?, current_timestamp)
            </value>
        </property>
        <property name="updateIncomingBatchSql">
            <value>
                update ${sync.table.prefix}_incoming_batch set status = ? where batch_id = ? and
                node_id = ? and status = ?
            </value>
        </property>
        <property name="insertIncomingBatchHistorySql">
            <value>
                insert into ${sync.table.prefix}_incoming_batch_hist (batch_id, node_id, status,
                network_millis, filter_millis, database_millis,
                host_name, byte_count, statement_count, fallback_insert_count, fallback_update_count,
                missing_delete_count, failed_row_number, start_time, end_time) values (?, ?, ?, ?,
                ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            </value>
        </property>
    </bean>

    <bean id="nodeService" class="org.jumpmind.symmetric.service.impl.NodeService"
        scope="singleton">
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="nodeChannelControlIgnoreSql">
            <value>
                update ${sync.table.prefix}_node_channel_ctl set ignore_enabled=? where node_id=?
                and channel_id=?
            </value>
        </property>
        <property name="insertNodeChannelControlSql">
            <value>
                insert into ${sync.table.prefix}_node_channel_ctl
                (node_id,channel_id,ignore_enabled,suspend_enabled) values(?,?,?,?)
            </value>
        </property>
        <property name="updateNodeSql">
            <value>
                update ${sync.table.prefix}_node set node_group_id=?, external_id=?,
                database_type=?, database_version=?, schema_version=?, symmetric_version=?,
                sync_url=?, heartbeat_time=?, sync_enabled=? where node_id = ?
            </value>
        </property>
        <property name="findNodeSql">
            <value>
                select node_id, node_group_id, external_id, sync_enabled, sync_url, schema_version,
                database_type, database_version, symmetric_version from ${sync.table.prefix}_node
                where node_id = ?
            </value>
        </property>
        <property name="findNodeByExternalIdSql">
            <value>
                select node_id, node_group_id, external_id, sync_enabled, sync_url, schema_version,
                database_type, database_version, symmetric_version from ${sync.table.prefix}_node
                where node_group_id = ? and external_id = ?
            </value>
        </property>
        <property name="findNodeSecuritySql">
            <value>
                select node_id, password, registration_enabled, registration_time,
                initial_load_enabled, initial_load_time from ${sync.table.prefix}_node_security
                where node_id = ?
            </value>
        </property>
        <property name="findNodeIdentitySql">
            <value>
                select c.node_id, c.node_group_id, c.external_id, c.sync_enabled, c.sync_url,
                c.schema_version, c.database_type, c.database_version, c.symmetric_version from
                ${sync.table.prefix}_node c inner join ${sync.table.prefix}_node_identity i on
                c.node_id = i.node_id
            </value>
        </property>
        <property name="isNodeRegisteredSql">
            <value>
                select count(*) from ${sync.table.prefix}_node_security s inner join
                ${sync.table.prefix}_node n on n.node_id=s.node_id where n.node_group_id=? and
                n.external_id=? and s.registration_time is not null and s.registration_enabled=0
            </value>
        </property>
        <property name="findNodesWhoTargetMeSql">
            <value>
                select c.node_id, c.node_group_id, c.external_id, c.sync_enabled, c.sync_url,
                c.schema_version, c.database_type, c.database_version, c.symmetric_version from
                ${sync.table.prefix}_node c inner join ${sync.table.prefix}_node_group_link d on
                c.node_group_id = d.source_node_group_id where d.target_node_group_id = ? and
                d.data_event_action = ?
            </value>
        </property>
        <property name="findNodesWhoITargetSql">
            <value>
                select c.node_id, c.node_group_id, c.external_id, c.sync_enabled, c.sync_url,
                c.schema_version, c.database_type, c.database_version, c.symmetric_version from
                ${sync.table.prefix}_node c inner join ${sync.table.prefix}_node_group_link d on
                c.node_group_id = d.target_node_group_id where d.source_node_group_id = ? and
                d.data_event_action = ?
            </value>
        </property>
        <property name="updateNodeSecuritySql">
            <value>
                update ${sync.table.prefix}_node_security set password = ?, registration_enabled =
                ?, registration_time = ?, initial_load_enabled = ?, initial_load_time = ? where
                node_id = ?
            </value>
        </property>
    </bean>

    <bean id="registrationService" class="org.jumpmind.symmetric.service.impl.RegistrationService"
        scope="singleton">
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="nodeService" ref="nodeService" />
        <property name="clusterService" ref="clusterService" />
        <property name="acknowledgeService" ref="acknowledgeService" />
        <property name="runtimeConfiguration" ref="runtimeConfiguration" />
        <property name="dataExtractorService" ref="dataExtractorService" />
        <property name="configurationService" ref="configurationService" />
        <property name="dataService" ref="dataService" />
        <property name="autoRegistration" value="${symmetric.auto.registration}" />
        <property name="autoReload" value="${symmetric.auto.reload}" />
        <property name="findNodeToRegisterSql">
            <value>
                select min(c.node_id) from ${sync.table.prefix}_node c inner join
                ${sync.table.prefix}_node_security s on c.node_id = s.node_id where
                s.registration_enabled = 1 and c.node_group_id = ? and c.external_id = ?
            </value>
        </property>
        <property name="registerNodeSql">
            <value>
                update ${sync.table.prefix}_node set sync_enabled = 1, sync_url = ?, schema_version
                = ?, database_type = ?, database_version = ?, symmetric_version = ? where node_id =
                ?
            </value>
        </property>
        <property name="registerNodeSecuritySql">
            <value>
                update ${sync.table.prefix}_node_security set registration_enabled = 0,
                registration_time = current_timestamp where node_id = ?
            </value>
        </property>
        <property name="reopenRegistrationSql">
            <value>
                update ${sync.table.prefix}_node_security set password = ?, registration_enabled =
                1, registration_time = null where node_id = ?
            </value>
        </property>
        <property name="openRegistrationNodeSql">
            <value>
                insert into ${sync.table.prefix}_node (node_id, node_group_id, external_id) values
                (?, ?, ?)
            </value>
        </property>
        <property name="openRegistrationNodeSecuritySql">
            <value>
                insert into ${sync.table.prefix}_node_security (node_id, password,
                registration_enabled) values (?, ?, 1)
            </value>
        </property>
    </bean>

    <bean id="acknowledgeService" class="org.jumpmind.symmetric.service.impl.AcknowledgeService"
        scope="singleton">
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="runtimeConfiguration" ref="runtimeConfiguration" />
        <property name="outgoingBatchHistoryService" ref="outgoingBatchHistoryService" />
        <property name="updateOutgoingBatchSql">
            <value>
                update ${sync.table.prefix}_outgoing_batch set status = ? where batch_id = ?
            </value>
        </property>
        <property name="selectDataIdSql">
            <value>
                select a.data_id from ${sync.table.prefix}_data a, ${sync.table.prefix}_data_event b
                where a.data_Id = b.data_Id and b.batch_id=? order by a.data_id asc
            </value>
        </property>
    </bean>

    <bean id="extractorContext" class="org.jumpmind.symmetric.extract.DataExtractorContext"
        scope="prototype">
    </bean>

    <bean id="dataExtractor" class="org.jumpmind.symmetric.extract.csv.CsvExtractor">
        <property name="dbDialect" ref="dbDialect" />
        <property name="runtimeConfiguration" ref="runtimeConfiguration" />
        <property name="nodeService" ref="nodeService" />
        <property name="dictionary">
            <map>
                <entry key="I">
                    <bean class="org.jumpmind.symmetric.extract.csv.StreamInsertDataCommand"></bean>
                </entry>
                <entry key="U">
                    <bean class="org.jumpmind.symmetric.extract.csv.StreamUpdateDataCommand"></bean>
                </entry>
                <entry key="D">
                    <bean class="org.jumpmind.symmetric.extract.csv.StreamDeleteDataCommand"></bean>
                </entry>
                <entry key="V">
                    <bean class="org.jumpmind.symmetric.extract.csv.StreamValidateDataCommand"></bean>
                </entry>
                <entry key="R">
                    <bean class="org.jumpmind.symmetric.extract.csv.StreamReloadDataCommand">
                        <property name="dataExtractorService" ref="dataExtractorService" />
                        <property name="configurationService" ref="configurationService" />
                        <property name="nodeService" ref="nodeService" />
                    </bean>
                </entry>
                <entry key="S">
                    <bean class="org.jumpmind.symmetric.extract.csv.StreamSQLDataCommand"></bean>
                </entry>
                <entry key="C">
                    <bean class="org.jumpmind.symmetric.extract.csv.StreamCreateDataCommand"></bean>
                </entry>
            </map>
        </property>
    </bean>

    <bean id="dataExtractor10" class="org.jumpmind.symmetric.extract.csv.CsvExtractor10">
        <property name="runtimeConfiguration" ref="runtimeConfiguration" />
        <property name="dictionary">
            <map>
                <entry key="I">
                    <bean class="org.jumpmind.symmetric.extract.csv.StreamInsertDataCommand"></bean>
                </entry>
                <entry key="U">
                    <bean class="org.jumpmind.symmetric.extract.csv.StreamUpdateDataCommand"></bean>
                </entry>
                <entry key="D">
                    <bean class="org.jumpmind.symmetric.extract.csv.StreamDeleteDataCommand"></bean>
                </entry>
                <entry key="V">
                    <bean class="org.jumpmind.symmetric.extract.csv.StreamValidateDataCommand"></bean>
                </entry>
                <entry key="R">
                    <bean class="org.jumpmind.symmetric.extract.csv.StreamReloadDataCommand">
                        <property name="dataExtractorService" ref="dataExtractorService" />
                        <property name="configurationService" ref="configurationService" />
                        <property name="nodeService" ref="nodeService" />
                    </bean>
                </entry>
                <entry key="S">
                    <bean class="org.jumpmind.symmetric.extract.csv.StreamSQLDataCommand"></bean>
                </entry>
            </map>
        </property>
    </bean>

    <bean id="outgoingBatchHistoryService"
        class="org.jumpmind.symmetric.service.impl.OutgoingBatchHistoryService" scope="singleton">
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="runtimeConfiguration" ref="runtimeConfiguration" />
        <property name="createdSql">
            <value>
                insert into ${sync.table.prefix}_outgoing_batch_hist (batch_id, status, event_time,
                data_event_count) values (?, 'NE', current_timestamp, ?)
            </value>
        </property>
        <property name="errorSql">
            <value>
                insert into ${sync.table.prefix}_outgoing_batch_hist (batch_id, status, event_time,
                failed_data_id) values (?, 'ER', current_timestamp, ?)
            </value>
        </property>
        <property name="okSql">
            <value>
                insert into ${sync.table.prefix}_outgoing_batch_hist (batch_id, status, event_time)
                values (?, 'OK', current_timestamp)
            </value>
        </property>
        <property name="sentSql">
            <value>
                insert into ${sync.table.prefix}_outgoing_batch_hist (batch_id, status, event_time)
                values (?, 'SE', current_timestamp)
            </value>
        </property>
    </bean>

    <bean id="upgradeService" class="org.jumpmind.symmetric.service.impl.UpgradeService">
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="runtimeConfiguration" ref="runtimeConfiguration" />
        <property name="nodeService" ref="nodeService" />
        <property name="upgradeTaskMap" ref="upgradeTaskMap" />
    </bean>

    <bean id="clusterService" class="org.jumpmind.symmetric.service.impl.ClusterService">
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="runtimeConfiguration" ref="runtimeConfiguration" />
        <property name="nodeService" ref="nodeService" />
        <property name="lockTimeoutInMilliseconds"
            value="${symmetric.runtime.cluster.lock.timeout.ms}" />
        <property name="lockDuringPurge" value="${symmetric.runtime.cluster.lock.during.purge}" />
        <property name="lockDuringPull" value="${symmetric.runtime.cluster.lock.during.pull}" />
        <property name="lockDuringPush" value="${symmetric.runtime.cluster.lock.during.push}" />
        <property name="lockDuringHeartbeat"
            value="${symmetric.runtime.cluster.lock.during.heartbeat}" />
        <property name="lockDuringSyncTriggers"
            value="${symmetric.runtime.cluster.lock.during.sync.triggers}" />
        <property name="aquireLockSql">
            <value>
                update ${sync.table.prefix}_lock set locking_server_id=?,
                lock_time=current_timestamp where lock_id=? and lock_action=? and (lock_time is null
                or lock_time &lt; ?)
            </value>
        </property>
        <property name="releaseLockSql">
            <value>
                update ${sync.table.prefix}_lock set lock_time=null where lock_id=? and
                lock_action=? and locking_server_id=?
            </value>
        </property>
        <property name="insertLockSql">
            <value>insert into ${sync.table.prefix}_lock (lock_id, lock_action) values(?,?)</value>
        </property>

    </bean>

    <bean id="purgeService" class="org.jumpmind.symmetric.service.impl.PurgeService">
        <property name="jdbcTemplate" ref="jdbcTemplate" />
        <property name="runtimeConfiguration" ref="runtimeConfiguration" />
        <property name="clusterService" ref="clusterService" />
        <property name="dbDialect" ref="dbDialect" />
        <property name="retentionInMinutes" value="${symmetric.runtime.purge.retention.minutes}" />
        <property name="maxNumOfDataIdsToPurgeInTx"
            value="${symmetric.runtime.job.purge.max.num.data.events.to.delete.in.tx}" />
        <property name="selectOutgoingBatchIdsToPurgeSql">
            <value>
                select batch_id, node_id from ${sync.table.prefix}_outgoing_batch where status='OK' and
                create_time &lt; ? order by batch_id asc
            </value>
        </property>
        <property name="deleteFromOutgoingBatchHistSql">
            <value>delete from ${sync.table.prefix}_outgoing_batch_hist where history_id &lt;= ?</value>
        </property>
        <property name="deleteFromOutgoingBatchSql">
            <value>delete from ${sync.table.prefix}_outgoing_batch where batch_id=?</value>
        </property>
        <property name="deleteFromEventDataIdSql">
            <value>delete from ${sync.table.prefix}_data_event where batch_id=? and node_id=?</value>
        </property>
        <property name="selectOutgoingBatchHistoryRangeSql">
            <value>select min(history_id),max(history_id) from ${sync.table.prefix}_outgoing_batch_hist where event_time &lt; ?</value>
        </property>
        <property name="selectMinDataIdSql">
            <value>
                 select min(data_id) from ${sync.table.prefix}_data
            </value>
        </property>
        <property name="selectMaxDataIdSql">
            <value>
                 select max(data_id) from ${sync.table.prefix}_data where create_time &lt; ?
            </value>
        </property>                        
        <property name="deleteFromDataSql">
            <value>
                 delete from ${sync.table.prefix}_data where data_id not in (select data_id from ${sync.table.prefix}_data_event where data_id &gt;= ? and data_id  &lt;= ?) and data_id &gt;= ? and data_id &lt;= ?
            </value>
        </property>
        <property name="selectIncomingBatchOrderByCreateTimeSql">
        <value>select batch_id, node_id, status, create_time from ${sync.table.prefix}_incoming_batch order by create_time asc</value>
        </property>
        <property name="deleteIncomingBatchesByNodeIdSql">
            <list>
                <value>delete from ${sync.table.prefix}_incoming_batch_hist where node_id=?</value>
                <value>delete from ${sync.table.prefix}_incoming_batch where node_id=?</value>
            </list>
        </property>
        <property name="incomingPurgeSql">
            <list>
                <value>
                    delete from ${sync.table.prefix}_incoming_batch_hist where batch_id=? and node_id=?
                </value>
                <value>
                    delete from ${sync.table.prefix}_incoming_batch where batch_id=? and node_id=?
                </value>
            </list>
        </property>
    </bean>

</beans>