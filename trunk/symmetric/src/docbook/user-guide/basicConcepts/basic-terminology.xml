<?xml version="1.0" encoding="UTF-8"?>
  <section id="terminology">
        <title>Terminology</title>
     
         <para>Before the complete data model is revealed, a few key terms should be explained. Terms such as "nodes", "groups", "links", "channels", "routers", 
        and "triggers" are fundamental to understanding SymmetricDS.</para>
        <section id="terminology-nodes">
            <title>Nodes</title>
            <para>
                A <emphasis>node</emphasis> is a single instance of SymmetricDS. It can be thought of as a proxy for a database which
                manages the synchronization of data. 
            </para>
            <para>    
                One use case where SymmetricDS has been used is in retail.
                An example retail deployment of SymmetricDS might include many point-of-sale workstations located at stores that may have 
                intermittent network connection to a central location.  These workstations might have point-sale-software that uses a local
                relational database.  The database is populated with items, prices and tax information from a centralized
                database.  The point-of-sale software looks up item information from the local database and also saves 
                sale information to the same database.   The persisted sales need to be propagated back to the centralized database.  
                In this example the following would be SymmetricDS nodes:
                <itemizedlist>
                    <listitem>Each point-of-sale workstation.</listitem>
                    <listitem>A central office database server.</listitem>                   
                </itemizedlist>
                A node instance of SymmetricDS is a program that is either embedded in another application or is running in the background as a service.  Centralized
                nodes that have many clients can be clustered to help disperse load.
            </para>
            <para>A node must be configured to communicate with the database it is synchronizing. This includes providing database connection information, database credentials, and depending on the database, a 
            JDBC driver library.  A node is identified to a registration server by its assigned <emphasis>node group id</emphasis> and its <emphasis>external id</emphasis>.  Based on those properties, the system
            determines if a node is allowed to register with the system, and if so, it is assigned a node id.  The node group identifies
            a tier of like nodes that have the same synchronization profile.  The external id is a domain-specific identifier, an <emphasis>externalId</emphasis> 
            that provides context within the local system.  For example, a server at a store may belong to the node group 'store' and have and external
            id of '00010.'           
           </para>
            <para>Node configuration is typically stored in a local properties file.  All other configuration is retrieved during registration
            and is stored in the SymmetricDS tables located in the database.</para>  
        </section>
        <section id="terminology-node-organization">
            <title>Node Organization</title>
            <para> Nodes in SymmetricDS are organized into an overall node network, such as hub-and-spoke, tree, etc.
                The hierarchy chosen varies based on the goals of the SymmetricDS installation.</para>
            <para> For example, the above retail store use case is a simple SymmetricDS hub-and-spoke network, 
                with the central server serving as the hub and the
                registers as the nodes at the end of each spoke. If this hub-and-spoke network where drawn as a tree hierarchy,
                the central office server would be the top node in the tree, and a series of child nodes representing each
                individual register would represent the lower level of the hierarchy.  </para>
            <para>
                <figure>
                    <title>Two Tiered Retail Store Deployment Example</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/two-tier-arch.gif" format="GIF" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>                
            <para>More complex topologies can also be used. Consider, for example, if the same retail example is expanded to include 
              store servers in each
              store to perform tasks such as opening the store for the day, reconciling registers, assigning employees, etc. 
              One approach to this new configuration would be to create a three-tier tree hierarchy. The highest tier, the centralized database, 
              connects with each store server's database. The store servers, in turn, communicate with the 
              individual point-of-sale workstations at the store.</para>                        
             <para>
                <figure>
                    <title>Three Tiered, In-Store Server, Retail Store Deployment Example</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/three-tier-arch.gif" format="GIF" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>    
        <para>One final example, again extending our original two-tier retail use case, would be to organize stores by "region" in the world.  
        This three tier architecture would introduce new regional servers (and corresponding regional databases)
        which would consolidate information specific to stores the regional server is responsible for.  The tiers in this case are
        therefore the central office server, regional servers, and individual store registers.         
        </para>
          <para>
                <figure>
                    <title>Three Tiered, Regional Server, Retail Store Deployment Example</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="images/three-tier-regional-arch.gif" format="GIF" />
                        </imageobject>
                    </mediaobject>
                </figure>
            </para>    
        <para>
        These are just three common examples of how one might organize nodes in Symmetric.  While the examples above were for the retail industry, 
        the organization, they could apply to a variety of application domains.
        </para>
        </section>
        <section id="terminology-node-groups">
            <title>Node Groups</title>
            <para>
                Once the organization of your SymmetricDS nodes has been chosen, each node in the network is assigned to a 
                node group.  Typically an individual tier in your network will represent one Node Group. Each Node Groups
                maps to a synchronization profile, which is just a list of the tables that are being synchronized to and from the different node groups.  Node groups represent
                a particular level of the overall node hierarchy. For the examples above, we might define a node
                groups of:
                <itemizedlist>
                    <listitem>"workstation", to represent each point-of-sale workstation</listitem>
                    <listitem>"corp" or "central-office" to represent the centralized node.</listitem>
                    <listitem>"store" to represent the store server that interacts with store workstations and sends and
                        receives data from a central office server.</listitem>
                    <listitem>"region" to represent the a regional server that interacts with store workstations and sends and
                        receives data from a central office server.</listitem>
                </itemizedlist>
                Considerable thought should be given to how node groups are organized.  Groups should be created for each set of nodes
                that synchronize the same tables.  Note that there are other mechanisms in SymmetricDS to route to individual nodes 
                or smaller subsets of nodes in a node group.  
                <para>
                For example, although you could, you would not want to create a node group
                for each store even though different tax rates need to be routed to each store.  Each store needs to synchronize the same tables
                to the same groups, so 'store' would be a good choice for a node group.
                </para>  
            </para>
        </section>
        <section id="terminology-node-group-links">
            <title>Node Group Links</title>
            <para>
              In SymmetricDS, a node group is <emphasis>linked</emphasis> to another node group through a node group link. 
              In addition to establishing the flow of data between the two node groups, the link also specifies whether data is <emphasis>pushed</emphasis> to or
              <emphasis>pulled</emphasis> from a node.
            </para>
        </section>
        <section id="terminology-channels">
            <title>Channels</title>
            <para>SymmetricDS enables, suspends, prioritizes, schedules and groups tables that are being synchronized 
                using <emphasis>channels</emphasis>.  Tables that are collected data for synchronization are assigned a 
                channel.  The default behavior of SymmetricDS is to halt synchronization if an error occurs.  However, 
                synchronization is only blocked for the channel that produced the error.
            </para> 
            <para>The frequency of synchronization and order that data gets synchronized is also controlled at 
            the channel level.
            </para>
            </section>
               <section id="terminology-triggers-routers">
                <title>Triggers and Routers</title>         
            <para> SymmetricDS uses database <emphasis>triggers</emphasis> to capture and record changes to data.  After the data is captured,
            <emphasis>routers</emphasis> choose the nodes that the data will be synchronized to. The default router configuration 
            is to synchronize data between all nodes in a node group.   Other router configurations can route based on hard coded 
            column values or matches between columns and some node attribute like external id.
            </para>
            <para> 
                Triggers can be configured to control whether data changes are captured on inserts, deletes, updates, or
                any combination thereof. They can also be configured to fire when data has been received from other nodes
                in order to propagate data to another tier or back to other nodes in the originating tier node group tier.
           </para>
           <para> 
                Database triggers are installed on a system when a router is linked to a trigger definition that has a source node group id 
                that matches the node group id of the current node.
           </para>
           <para>
                Routers provided in the base implementation currently include:
                <itemizedlist>
                    <listitem>Column Match Router - a router that compares old or new column values to a constant value or the
                        value of a node's external_id or node_id.</listitem>
                    <listitem>Sub-select Router - a router that executes a SQL expression against the database to select nodes to
                        route to. This SQL expression can be passed values of old and new column values.</listitem>
                    <listitem>Bean Shell Router - a router that executes a BSH expression in order to select nodes to route to.
                        The BSH expression can use the the old and new column values.</listitem>
                    <listitem>Xml Publishing Router - a router the publishes data changes directly to a messaging solution instead
                        of transmitting changes to registered nodes.  This router must be configured manually in XML as an extension point.</listitem>
                </itemizedlist>
                The mapping between the set of triggers and set of routers is many-to-many.  This means that one trigger can capture changes and route
                to multiple locations.  It also means that one router can be defined an associated with many different triggers.
            </para>
        </section>
    </section>
    