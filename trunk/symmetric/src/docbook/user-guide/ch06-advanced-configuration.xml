<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="ch06-advanced-configuration" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml">
    <title>Advanced Configuration</title>
    <section>
        <title>Dead Triggers</title>
        <para>
            Normally a Trigger is specified to capture data changes to a table and send them to
            a target Node Group.  A dead Trigger is one that does not capture data changes.
            In other words, the sync_on_insert, sync_on_update, and sync_on_delete properties
            for the Trigger are all set to false.  Because the Trigger is specified, it will
            be included in the initial load of data for target Nodes.
        </para>
        <para>
            A dead Trigger might be used to load a read-only lookup table.  It could be used
            to load a table that needs populated with example or default data.
            Another use is a recovery load of data for tables that have a single direction
            of synchronization.  For example, a retail store records sales transaction that
            synchronize in one direction by trickling back to the central office.
            If the retail store needs to recover all the sales transactions, they can be sent
            are part of an initial load from the central office by setting up dead Triggers
            that "sync" in that direction.
        </para>
        <para>
            The following SQL statement sets up a non-syncing dead Trigger that sends
            the sale_transaction table to the "store" Node Group from the "corp" Node Group during
            an initial load.
            <programlisting>
<![CDATA[insert into sym_trigger 
(source_table_name, source_node_group_id, target_node_group_id, channel_id, 
sync_on_insert, sync_on_update, sync_on_delete, 
initial_load_order, last_updated_by, last_updated_time, create_time)
values('sale_transaction', 'corp', 'store', 'sale_transaction', 
0, 0, 0, 
105, 'demo', current_timestamp, current_timestamp);]]></programlisting>
        </para>
    </section>
    <section>
        <title>Filtering and Rerouting</title>
        <para>
            Data can be filtered as it is loaded into the target database or when
            it is extracted from the source database.
        </para>
        <section>
            <title>IDataLoaderFilter</title>
            <para>
                As data is loaded into the target database, a filter can change the
                data in a column or save it somewhere else.  One possible use might be to
                route credit card data to a secure database and blank it out as it loads 
                into less-restricted reporting database.
            </para>
            <para>
                A class implementing the IDataLoaderFilter interface is given to the
                DataLoaderService in order to receive callbacks when data is inserted,
                updated, or deleted.
                
                <programlisting><![CDATA[public MyFilter implements IDataLoaderFilter {
    protected IDataLoaderService dataLoaderService; 
 
    public void init() { 
        dataLoaderService.addDataLoaderFilter(this); 
    } 
 
    public void filterInsert(IDataLoaderContext context,
        String[] columnValues) {
    }
    
    public void filterUpdate(IDataLoaderContext context, 
        String[] columnValues, String[] keyValues) {
    }
    
    public void filterDelete(IDataLoaderContext context, 
        String[] keyValues) {
    }

    public void setDataLoaderService(IDataLoaderService dataLoaderService) { 
        this.dataLoaderService = dataLoaderService; 
    } 
}]]></programlisting>
            </para>
            <para>
                The filter class is specified as a Spring-managed bean so that it can
                get a reference to the DataLoaderService.  A custom Spring XML file
                is specified as the following.
                
                <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?> 
<beans xmlns="http://www.springframework.org/schema/beans" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"> 
 
    <bean id="myFilter" class="com.mydomain.MyFilter" 
            scope="singleton" init-method="init"> 
        <property name="dataLoaderService" ref="dataLoaderService" /> 
    </bean> 
</beans>]]></programlisting>
            </para>
            <para>
                To include the custom Spring XML file during the initialization
                of SymmetricDS, list the filename in the web.xml as a context
                parameter:
                
                <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE web-app
      PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
      "http://java.sun.com/dtd/web-app_2_3.dtd">
<web-app>
    ...
    <context-param> 
        <param-name>contextConfigLocation</param-name> 
        <param-value>classpath:my-spring.xml</param-value> 
    </context-param> 
    ...
</web-app>]]></programlisting>
            </para>
        </section>
        <section>
            <title>IColumnFilter</title>
            <para></para>
        </section>
        <section>
            <title>IExtractorListener</title>
            <para></para>
        </section>
    </section>
    <section>
        <title>Secure Transport</title>
        <para></para>
    </section>
</chapter>
