<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="ch02-getting-started" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:svg="http://www.w3.org/2000/svg" xmlns:ns="http://docbook.org/ns/docbook"
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:html="http://www.w3.org/1999/xhtml">
    <title>Getting Started</title>
    <para> This chapter is a hands-on tutorial that demonstrates how to synchronize the sample database between two running
        instances of SymmetricDS. This example models a retail business that has a central office database (called "root") and
        multiple retail store databases (called "client"). The root database sends changes to the client for item data, such as
        item number, description, and price. The client database sends changes to the root for sale transaction data, such as time
        of sale and items sold. The sample configuration specifies synchronization with a pull method for the client to receive
        data from root, and a push method for the root to receive data from client.</para>
    <para> To get started, we create separate databases for the root and client where sample tables will be created and populated.
        We use a configuration file to run an instance of SymmetricDS, called a node, on each database. To link the nodes
        together, we register the client node with the root node. For this tutorial, the root database is pre-populated with data,
        while the client database is left empty. To load the data on the client database, we request the root node sends a
        "reload" to the client node. With the two databases in sync, we make changes to data in the tables and observe the changes
        being synchronized.</para>
    <section id="ch02-terminology">
        <title>Terminology</title>
        <para>SymmetricDS has a few key terms and concepts that must be understood to be able to configure and use SymmetricDS
            effectively. Terms such as "nodes", "channels", "routers", and "triggers" will be used extensively throughout this
            guide, and thus we will define them now.</para>
        <section id="ch02-terminology-nodes">
            <title>Nodes</title>
            <para>
                A *node* is technically a single instance of SymmetricDS, but can really be thought of as a location which
                captures and *synchronizes* (receives or sends) data. Normally a node has a corresponding database that is
                associated with the node. Examples of nodes include:
                <itemizedlist>
                    <listitem>A single retail store register which contains a database that contains item information, item
                        prices, and saves sale information.</listitem>
                    <listitem>A laptop computer that is used to collect new employee hire information for later sending to a
                        central server.</listitem>
                    <listitem>A central office server that is used for aggregating sales data that has been sent from retail store
                        registers.</listitem>
                    <listitem>Others?</listitem>
                </itemizedlist>
                In all of these examples, an instance of SymmetricDS would be installed on the computer and would interact with
                the database on the computer.
            </para>
        </section>
        <section id="ch02-terminology-node-topology">
            <title>Node Topology</title>
            <para> Nodes in SymmetricDS are organized into an overall node topology, such as hub-and-spoke, tree-hiearchy, etc.
                The hierarchy chosen varies based on the particular goals of the SymmetricDS installation.</para>
            <para> For example, consider a small retail company which has a single register in each store. The company wishes to
                collect sales data on a common, central server, for use in tracking and reporting sales. The company might also
                want to be able to update prices on the central server and have the prices automatically sent down to each
                register. This is a simple SymmetricDS hub-and-spoke topology, with the central server serving as the hub and the
                registers as the nodes at the end of each spoke. If this hub-and-spoke topology where drawn as a tree hierarchy,
                the central office server would be the top node in the tree, and a series of child nodes representing each
                individual register would represent the lower level of the hierarchy.</para>
            <para> More complex topologies can also be used. Consider, for example, the same retail company that has expanded to
                have multiple registers in each store. The company may choose to place store servers in each store to perform
                tasks such as opening the store for the day, reconciling registers, assigning employees, etc. One approach to this
                could be to create a three-tier tree hierarchy. The highest tier, the central office, connects with each store's
                server. The store servers, in turn, communicate with the individual registers at the store.</para>
        </section>
        <section id="ch02-terminology-node-groups">
            <title>Node Groups</title>
            <para>
                As you can see, the individual nodes in a SymmetricDS installation (registers, servers, etc.) naturally organize
                into tiers or levels in an overall hierarchy, and typically the grouped nodes share common attributes. In fact, it
                is quite common for SymmetricDS to have hundreds or thousands of nodes sending and receiving information. Nodes
                which share common attributes are assigned to *node groups*. These node groups are frequently used to represent
                all nodes at a particular level of the overall node hierarchy. For the examples above, we might define a node
                group of:
                <itemizedlist>
                    <listitem>"register", to represent each store register</listitem>
                    <listitem>"hr-laptop", to represent all laptops that are used to collect employee information when detached
                        from the network.</listitem>
                    <listitem>"corp" or "central-office" to represent the node(s) that are aggregating sales data.</listitem>
                    <listitem>"store-server" to represent the back-office server that interacts with store registers and sends and
                        receives data from a central office server.</listitem>
                </itemizedlist>
                Node groups are used to ease configuration, primarily. For example, you can define the method in which data is
                synchronized by node group. In addition, specifying the specific data to be synchronized is done based on node
                groups.
            </para>
        </section>
        <section id="ch02-terminology-node-group-links">
            <title>Moving Data - Node Group Links and Push/Pull</title>
            <para> In SymmetricDS, a node group is *linked* to another node group through a node group link. In addition to
                establishing the flow of data between the two node groups, the link also specifies whether data is *pushed* to or
                *pulled* from a node.</para>
        </section>
        <section id="ch02-terminology-channels">
            <title>Channels</title>
            <para> In most SymmetricDS applications, not all data is created the same. Inevitably, some data is more important
                than the other data. SymmetricDS supports this idea through the concept of data channels, or *channels* for short.
                In SymmetricDS, you can assign a priority to individual channels such that your most important data is
                synchronized first. Through the use of channels you can also control how much data is synchronized in each channel
                each time. In addition, if synchronization errors should occur, the errors only block the individual channel in
                which they have occurred. Thus, other channels can continue synchronizing even if a particular channel is in
                error. Finally, data synchronization can be enabled or disabled by channel.</para>
            <section id="ch02-terminology-triggers-routers">
                <title>Synch Conditions (Triggers and Routers)</title>
            </section>
            <para> SymmetricDS makes extensive use of database triggers to capture and record changes to data of interest to a
                particular SymmetricDS instance. SymmetricDS creates these triggers automatically for the user based on
                configuration specified in the SymmetricDS *trigger* configuration tables. Triggers can be quite simple or quite
                sophisticated. You can, for example, control whether data changes are captured on inserts, deletes, updates, or
                any combination thereof. You can control whether you trigger changes when data has been received from other nodes
                (i.e., synchronize on incoming batches). Triggers are configured based on source and target *node groups*.</para>
            <para> While triggers specify which data changes to capture, *routers* are used to specify when and where the data
                changes are to be sent. You can, for example, choose to only route data when certain column values match a
                particular constant or come from a particular node.</para>
            <para> Routers can also specify whether to route when a node is undergoing what is known as an initial load (a clean,
                fresh load of data) or whether to route under normal (non-initial-load) synchronizing situations). Finally,
                routers can even be used to override default behavior and route by way of XML publishing.</para>
            <para>
                Routers provided in the base implementation currently include:
                <itemizedlist>
                    <listitem>Column Match Router - a router that compares old or new column values to a constant value or the
                        value of a node's external_id or node_id.</listitem>
                    <listitem>Sub-select Router - a router that executes a SQL expression against the database to select nodes to
                        route to. This SQL expression can be passed values of old and new column values.</listitem>
                    <listitem>Bean Shell Router - a router that executes a BSH expression in order to select nodes to route to.
                        The BSH expression can use the the old and new column values.</listitem>
                    <listitem>Xml Publishing Router - a router the publishes data changes directly to a messaging solution instead
                        of transmitting changes to registered nodes.</listitem>
                </itemizedlist>
                The mapping between the set of triggers and set of routers is many-to-many. More than one trigger can make use of
                a given router and vice versa.
            </para>
        </section>
    </section>
    <section id="ch02-install">
        <title>Installing SymmetricDS</title>
        <para> Install the SymmetricDS software and configure it with your database connection information.</para>
        <procedure>
            <step>
                <para>
                    Download the
                    <ulink url="http://sourceforge.net/project/showfiles.php?group_id=206470"> symmetric-ds-1.6.X.zip</ulink>
                    file from
                    <ulink url="http://www.symmetricds.org/">http://www.symmetricds.org/</ulink>
                </para>
            </step>
            <step>
                <para>
                    Unzip the file in any directory you choose. This will create a
                    <filename class="directory">symmetric-ds-1.6.X</filename>
                    subdirectory, which corresponds to the version you downloaded.
                </para>
            </step>
            <step>
                <para>Edit the database properties in the following property files for the root and client nodes:</para>
                <para>
                    <itemizedlist spacing="compact">
                        <listitem>
                            <para>
                                <filename>samples/root.properties</filename>
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <filename>samples/client.properties</filename>
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>
            </step>
            <step>
                <para>
                    Set the following properties in
                    <emphasis>both</emphasis>
                    files to specify how to connect to the database:
                </para>
                <programlisting><![CDATA[# The class name for the JDBC Driver
db.driver=com.mysql.jdbc.Driver

# The JDBC URL used to connect to the database
db.url=jdbc:mysql://localhost/sample

# The user to login as who can create and update tables
db.user=symmetric

# The password for the user to login as
db.password=secret]]></programlisting>
            </step>
            <step>
                <para>
                    Set the following property in the
                    <filename>client.properties</filename>
                    file to specify where the root node can be contacted:
                </para>
                <programlisting><![CDATA[# The HTTP URL of the root node to contact for registration
registration.url=http://localhost:8080/sync]]></programlisting>
                <para> For the tutorial, the client database starts out empty, and the node is not registered. Registration is the
                    process where the node receives its configuration and stores it in the database. The configuration describes
                    which database tables to synchronize and with which nodes. When an unregistered node starts up, it will
                    register with the node specified by the registration URL. The registration node centrally controls nodes on
                    the network by allowing registration and returning configuration. In this tutorial, the registration node is
                    the root node, which also participates in synchronization with other nodes.</para>
            </step>
        </procedure>
    </section>
    <section id="ch02-create-database">
        <title>Creating and Populating Your Databases</title>
        <important>
            <para> You must first create the databases for your root and client nodes using the administration tools provided by
                your database vendor. Make sure the name of the databases you create match the settings in the properties files.
            </para>
            <para>
                See the appendix
                <link linkend="databases">Database Notes</link>
                for compatibility with your specific database.
            </para>
        </important>
        <para>
            Create the sample tables in the
            <emphasis>root</emphasis>
            node database, load the sample data, and load the sample configuration.
        </para>
        <procedure>
            <step>
                <para>
                    Open a command prompt and navigate to the
                    <filename class="directory">samples</filename>
                    subdirectory of your SymmetricDS installation.
                </para>
            </step>
            <step>
                <para>Create the sample tables in the root database.</para>
                <para>
                    <command>../bin/sym -p root.properties --run-ddl create_sample.xml</command>
                </para>
                <para> Note that the warning messages from the command are safe to ignore.</para>
            </step>
            <step>
                <para> Create the SymmetricDS tables in the root node database. These tables will contain the configuration for
                    synchronization. The following command uses the auto-creation feature to create all the necessary SymmetricDS
                    system tables.</para>
                <para>
                    <command>../bin/sym -p root.properties --auto-create</command>
                </para>
            </step>
            <step>
                <para>Load the sample data and configuration into the root node database.</para>
                <para>
                    <command>../bin/sym -p root.properties --run-sql insert_sample.sql</command>
                </para>
            </step>
        </procedure>
        <para>
            Create the sample tables in the
            <emphasis>client</emphasis>
            node database to prepare it for receiving data.
        </para>
        <procedure>
            <step>
                <para>
                    Open a command prompt and navigate to the
                    <filename class="directory">samples</filename>
                    subdirectory of your SymmetricDS installation.
                </para>
            </step>
            <step>
                <para>Create the sample tables in the client database.</para>
                <para>
                    <command> ../bin/sym -p client.properties --run-ddl create_sample.xml</command>
                </para>
                <para> Note that the warning messages from the command are safe to ignore.</para>
            </step>
        </procedure>
        <para>
            Verify
            <emphasis>both</emphasis>
            databases by logging in and listing the tables.
        </para>
        <procedure>
            <step>
                <para> Find the item tables that sync from root to client: item and item_selling_price.</para>
            </step>
            <step>
                <para> Find the sales tables that sync from client to root: sale_transaction and sale_return_line_item.</para>
            </step>
            <step>
                <para> Find the SymmetricDS system tables, which have a prefix of "sym_".</para>
            </step>
        </procedure>
    </section>
    <section id="ch02-start-server">
        <title>Starting SymmetricDS</title>
        <para>Start the SymmetricDS nodes and observe the logging output.</para>
        <procedure>
            <step>
                <para>
                    Open a command prompt and navigate to the
                    <filename class="directory">samples</filename>
                    subdirectory of your SymmetricDS installation.
                </para>
            </step>
            <step>
                <para>Start the root node server.</para>
                <para>
                    <command>../bin/sym -p root.properties --port 8080 --server</command>
                </para>
                <para> The root node server starts up and creates all the triggers that were configured by the sample
                    configuration. It listens on port 8080 for synchronization and registration requests.</para>
            </step>
            <step>
                <para>Start the client node server.</para>
                <para>
                    <command>../bin/sym -p client.properties --port 9090 --server</command>
                </para>
                <para> The client node server starts up and uses the auto-creation feature to create the SymmetricDS system
                    tables. It begins polling the root node in order to register. Since registration is not yet open, the client
                    node receives an authorization failure (HTTP response of 403).</para>
            </step>
        </procedure>
        <tip>
            <title>Tip</title>
            <para> If you want to change the port number used by SymmetricDS, you need to also set the my.url runtime property to
                match. The default value is:</para>
            <programlisting><![CDATA[my.url=http://localhost:8080/sync]]></programlisting>
        </tip>
    </section>
    <section id="ch02-register-node">
        <title>Registering a Node</title>
        <para> Open registration for the client node using the root node administration feature.</para>
        <procedure>
            <step>
                <para>
                    Open a command prompt and navigate to the
                    <filename class="directory">samples</filename>
                    subdirectory of your SymmetricDS installation.
                </para>
            </step>
            <step>
                <para>Open registration for the client node server.</para>
                <para>
                    <command> ../bin/sym -p root.properties --open-registration "store,1"</command>
                </para>
                <para>
                    The registration is opened for a node group called "store" with an external identifier of "1". This
                    information matches the settings in
                    <filename>client.properties</filename>
                    for the client node. Each node is assigned to a group and is given an external ID that makes sense for the
                    application. In this tutorial, we have retail stores that run SymmetricDS, so we named our group "store" and
                    we used numeric identifiers starting with "1".
                </para>
            </step>
            <step>
                <para> Watch the logging output of the client node to see it successfully register with the root node. The client
                    is configured to attempt registration each minute. Once registered, the root and client are enabled for
                    synchronization.</para>
            </step>
        </procedure>
    </section>
    <section id="ch02-initial-load">
        <title>Sending Initial Load</title>
        <para> Send an initial load of data to the client node using the root node administration feature.</para>
        <procedure>
            <step>
                <para>
                    Open a command prompt and navigate to the
                    <filename class="directory">samples</filename>
                    subdirectory of your SymmetricDS installation.
                </para>
            </step>
            <step>
                <para>Send an initial load of data to the client node server.</para>
                <para>
                    <command>../bin/sym -p root.properties --reload-node 1</command>
                </para>
                <para> With this command, the root node queues up an initial load for the client node that will be sent the next
                    time the client performs its pull. The initial load includes data for each table that is configured for
                    synchronization.</para>
            </step>
            <step>
                <para> Watch the logging output of both nodes to see the data transfer. The client is configured to pull data from
                    the root each minute.</para>
            </step>
        </procedure>
    </section>
    <section id="ch02-pull">
        <title>Pulling Data</title>
        <para> Modify data in the root database. The changes are propagated to the client database during pull synchronization.
        </para>
        <procedure>
            <step>
                <para>Open an interactive SQL session with the root database.</para>
            </step>
            <step>
                <para>Add a new item for sale:</para>
                <para>
                    <command> insert into item_selling_price (price_id, price) values (55, 0.65);</command>
                </para>
                <para>
                    <command> insert into item (item_id, price_id, name) values (110000055, 55, 'Soft Drink');</command>
                </para>
                <para> Once the statements are committed, the data change is captured and queued for the client node to pull.
                </para>
            </step>
            <step>
                <para> Watch the logging output of both nodes to see the data transfer. The client is configured to pull data from
                    the root each minute.</para>
            </step>
            <step>
                <para> Verify that the new data arrives in the client database using another interactive SQL session.</para>
            </step>
        </procedure>
    </section>
    <section id="ch02-push">
        <title>Pushing Data</title>
        <para> Modify data in the client database. The changes are propagated to the root database during push synchronization.
        </para>
        <procedure>
            <step>
                <para>Open an interactive SQL session with the client database.</para>
            </step>
            <step>
                <para>Add a new sale to the client database:</para>
                <para>
                    <command> insert into sale_transaction (tran_id, store, workstation, day, seq) values (1000, '1', '3',
                        '2007-11-01', 100);</command>
                </para>
                <para>
                    <command> insert into sale_return_line_item (tran_id, item_id, price, quantity) values (1000, 110000055, 0.65,
                        1);</command>
                </para>
                <para> Once the statements are committed, the data change is captured and queued for the client node to push.
                </para>
            </step>
            <step>
                <para> Watch the logging output of both nodes to see the data transfer. The client is configured to push data to
                    the root each minute.</para>
            </step>
        </procedure>
    </section>
    <section id="ch02-verify-outgoing">
        <title>Verifying Outgoing Batches</title>
        <para> A batch is used for tracking and sending data changes to nodes. The sending node creates a batch and the receiving
            node acknowledges it. A batch in error is retried during synchronization attempts, but only after data changes in
            other channels are allowed to be sent. Channels are categories assigned to tables for the purpose of independent
            synchronization and control. Batches for a channel are not created when a batch in the channel is in error status.
        </para>
        <procedure>
            <step>
                <para>Open an interactive SQL session with either the root or client database.</para>
            </step>
            <step>
                <para> Verify that the data change was captured:</para>
                <para>
                    <command> select * from sym_data where table_name like 'item%' or table_name like 'sale%';</command>
                </para>
                <para> Each row represents a row of data that was changed. The event_type is "I" for insert, "U" for update", or
                    "D" for delete. For insert and update, the captured data values are listed in row_data. For update and delete,
                    the primary key values are listed in pk_data.</para>
            </step>
            <step>
                <para> Verify that the data change was routed to a node, using the data_id from the previous step:</para>
                <para>
                    <command> select * from sym_data_event where data_id = ?;</command>
                </para>
                <para> When the batched flag is set, the data change is assigned to a batch using a batch_id that is used to track
                    and synchronize the data. Batches are created and assigned during a push or pull synchronization.</para>
            </step>
            <step>
                <para> Verify that the data change was batched, sent, and acknowledged, using the batch_id from the previous step:
                </para>
                <para>
                    <command> select * from sym_outgoing_batch where batch_id = ?;</command>
                </para>
                <para> A batch represents a collection of changes to be sent to a node. The batch is created during a push or pull
                    synchronization, when the status is set to "NE" for new. The receiving node acknowledges the batch with a
                    status of "OK" for success or "ER" for error.</para>
            </step>
            <step>
                <para> Verify that the batch history was recorded, using the batch_id from the previous step:</para>
                <para>
                    <command> select * from sym_outgoing_batch_hist where batch_id = ?;</command>
                </para>
                <para> Work performed on the batch is recorded in the history table. A new batch with status of "NE" records the
                    number of data changes it contains in the data_event_count field. The status of "SE" shows that a batch is
                    being sent to a node. The acknowledgement status from the receiving node is also recorded. If the status is
                    error, the failed_data_id indicates which row in sym_data caused the error.</para>
            </step>
        </procedure>
    </section>
    <section id="ch02-verify-incoming">
        <title>Verifying Incoming Batches</title>
        <para> The receiving node keeps track of the batches it acknowledges and records statistics about loading the data.
            Duplicate batches are skipped by default, but this behavior can be changed with the incoming.batches.skip.duplicates
            runtime property.</para>
        <procedure>
            <step>
                <para>Open an interactive SQL session with either the root or client database.</para>
            </step>
            <step>
                <para> Verify that the batch was acknowledged, using a batch_id from the previous section:</para>
                <para>
                    <command> select * from sym_incoming_batch where batch_id = ?;</command>
                </para>
                <para> A batch represents a collection of changes loaded by the node. The sending node that created the batch is
                    recorded. The status is either "OK" for success or "ER" for error.</para>
            </step>
            <step>
                <para> Verify that the batch history was recorded, using the batch_id from the previous step:</para>
                <para>
                    <command> select * from sym_incoming_batch_hist where batch_id = ?;</command>
                </para>
                <para> Work performed on the batch is recorded in the history table. If a duplicate batch was skipped, the status
                    is recorded as "SK". Otherwise, the status is either "OK" for success or "ER" for error. The statement_count
                    is the number of rows loaded and the byte_count is the size of the batch in bytes. The database_millis is the
                    amount of time in milliseconds spent loading data in the database.</para>
            </step>
        </procedure>
    </section>
</chapter>