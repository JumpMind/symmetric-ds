<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
    http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd" default-lazy-init="true">

    <bean id="msSqlStringTemplate" class="java.lang.String">
        <constructor-arg>
            <value>
                <![CDATA[ case when $(tableAlias)."$(columnName)" is null then '' else '"' + replace(replace($(tableAlias)."$(columnName)",'\','\\'),'"','\"') + '"' end +','+]]>
            </value>
        </constructor-arg>
    </bean>

    <bean id="msSqlDialect" class="org.jumpmind.symmetric.db.mssql.MsSqlDbDialect"
        scope="prototype">
        <property name="tablePrefix" value="$[sym.sync.table.prefix]" />
        <property name="parameterService" ref="parameterService" />
        <property name="defaultSchema" value="$[sym.db.default.schema]" />
        <property name="streamingResultsFetchSize" value="$[sym.db.jdbc.streaming.results.fetch.size]" />
        <property name="sqlTemplate">
            <bean class="org.jumpmind.symmetric.db.SqlTemplate">
                <property name="triggerPrefix" value="$[sym.trigger.prefix]" />
                <property name="functionInstalledSql">
                    <value>
                        <![CDATA[select count(object_name(object_id('$(functionName)')))]]>
                    </value>
                </property>
                <property name="functionTemplatesToInstall">
                    <map>
                        <entry key="fn_sym_base64_encode">
                            <value>
                                <![CDATA[ 
                                create function dbo.fn_sym_base64_encode (@data varbinary(max)) returns varchar(max)
                                  with schemabinding, returns null on null input
                                  begin
                                    return ( select [text()] = @data for xml path('') )
                                  end                                
                                ]]>
                            </value>
                        </entry>
                        <entry key="fn_sym_triggers_disabled">
                            <value>
                                <![CDATA[
                                create function dbo.fn_sym_triggers_disabled() returns smallint
                                begin
                                  declare @disabled varchar(1);
                                  set @disabled = coalesce(replace(substring(cast(context_info() as varchar), 1, 1), 0x0, ''), '');
                                  if @disabled is null or @disabled != '1'
                                    return 0;
                                  return 1;
                                end
                                ]]>
                            </value>
                        </entry>
                        <entry key="fn_sym_node_disabled">
                            <value>
                                <![CDATA[
                                create function dbo.fn_sym_node_disabled() returns varchar(50)
                                begin
                                  declare @node varchar(50);
                                  set @node = coalesce(replace(substring(cast(context_info() as varchar), 2, 50), 0x0, ''), '');
                                  return @node;
                                end
                                ]]>
                            </value>
                        </entry>
                    </map>
                </property>
                <property name="stringColumnTemplate" ref="msSqlStringTemplate" />
                <!-- TODO, We may have to make callbacks to the $(origTableAlias)inal table because SQL Server does not allow access to binary or clob data from a trigger -->
                <property name="clobColumnTemplate">
                    <value>
                        <![CDATA[ case when $(origTableAlias)."$(columnName)" is null then '' else '"' + replace(replace(cast($(origTableAlias)."$(columnName)" as varchar(max)),'\','\\'),'"','\"') + '"' end +','+]]>
                    </value>
                </property>
                <property name="blobColumnTemplate">
                    <value>
                        <![CDATA[ case when $(origTableAlias)."$(columnName)" is null then '' else '"' + replace(replace(dbo.fn_sym_base64_encode($(origTableAlias)."$(columnName)"),'\','\\'),'"','\"') + '"' end +','+]]>
                    </value>
                </property>
                <property name="numberColumnTemplate">
                    <value>
                        <![CDATA[case when $(tableAlias)."$(columnName)" is null then '' else ('"' + cast($(tableAlias)."$(columnName)" as varchar) + '"') end+','+]]>
                    </value>
                </property>
                <!-- TODO -->
                <property name="datetimeColumnTemplate">
                    <value>
                        <![CDATA[case when $(tableAlias)."$(columnName)" is null then '' else ('"' + convert(varchar,$(tableAlias)."$(columnName)",121) + '"') end +','+]]>
                    </value>
                </property>
                <property name="booleanColumnTemplate">
                    <value>
                        <![CDATA[case when $(tableAlias)."$(columnName)" is null then '' when $(tableAlias)."$(columnName)" = 1 then '"1"' else '"0"' end +','+]]>
                    </value>
                </property>
                <property name="triggerConcatCharacter" value="+" />
                <property name="newTriggerValue" value="inserted" />
                <property name="oldTriggerValue" value="deleted" />
                <property name="sqlTemplates">
                    <map>
                        <entry key="insertTriggerTemplate">
                            <value>
                                <![CDATA[
                                create trigger $(triggerName) on $(schemaName)$(tableName) after insert as
                                begin
                                  declare @TransactionId varchar(1000)
                                  declare @DataRow varchar(max)
                                  $(declareNewKeyVariables)
                                  if (@@TRANCOUNT > 0) begin
                                    execute sp_getbindtoken @TransactionId output;
                                  end
                                  if ($(syncOnIncomingBatchCondition)) begin
                                    declare DataCursor cursor local for
                                    $(if:containsBlobClobColumns)
                                       select $(columns), $(newKeyNames) from inserted inner join $(schemaName)$(tableName) $(origTableAlias) on $(tableNewPrimaryKeyJoin) where $(syncOnInsertCondition)
                                    $(else:containsBlobClobColumns)
                                       select $(columns), $(newKeyNames) from inserted where $(syncOnInsertCondition)                                    
                                    $(end:containsBlobClobColumns)                                    
                                       open DataCursor
                                       fetch next from DataCursor into @DataRow, $(newKeyVariables)
                                       while @@FETCH_STATUS = 0 begin
                                           insert into $(defaultCatalog)$(defaultSchema)$(prefixName)_data (table_name, event_type, trigger_hist_id, row_data, create_time) 
                                             values('$(targetTableName)','I', $(triggerHistoryId), @DataRow, current_timestamp)                                   
                                           insert into $(defaultCatalog)$(defaultSchema)$(prefixName)_data_event (node_id, data_id, channel_id, transaction_id)
                                             select c.node_id, @@IDENTITY, '$(channelName)', $(txIdExpression)
                                             from $(defaultCatalog)$(defaultSchema)$(prefixName)_node c, inserted
                                             where $(varNewPrimaryKeyJoin)
                                             and (c.node_group_id='$(targetGroupId)' and c.sync_enabled=1 and ($(defaultCatalog)dbo.fn_sym_node_disabled() != c.node_id)) $(nodeSelectWhere)
                                           fetch next from DataCursor into @DataRow, $(newKeyVariables)
                                       end
                                       close DataCursor
                                       deallocate DataCursor
                                  end
                                end                                
                                ]]>
                            </value>
                        </entry>
                        <entry key="updateTriggerTemplate">
                            <value>
                                <![CDATA[                                
                                create trigger $(triggerName) on $(schemaName)$(tableName) after update as
                                begin
                                  declare @TransactionId varchar(1000)
                                  declare @DataRow varchar(max)
                                  declare @OldPk varchar(2000)
                                  declare @OldDataRow varchar(max)
                                  $(declareOldKeyVariables)
                                  $(declareNewKeyVariables)
                                  if (@@TRANCOUNT > 0) begin
                                    execute sp_getbindtoken @TransactionId output;
                                  end
                                  if ($(syncOnIncomingBatchCondition)) begin
                                    declare DataCursor cursor local for
                                    $(if:containsBlobClobColumns)
                                       select $(columns), $(oldKeys), $(oldColumns), $(oldKeyNames), $(newKeyNames) from inserted inner join $(schemaName)$(tableName) $(origTableAlias) on $(tableNewPrimaryKeyJoin) inner join deleted on $(oldNewPrimaryKeyJoin) where $(syncOnInsertCondition)
                                    $(else:containsBlobClobColumns)
                                       select $(columns), $(oldKeys), $(oldColumns), $(oldKeyNames), $(newKeyNames) from inserted inner join deleted on $(oldNewPrimaryKeyJoin) where $(syncOnInsertCondition)                                    
                                    $(end:containsBlobClobColumns)
                                       open DataCursor
                                       fetch next from DataCursor into @DataRow, @OldPk, @OldDataRow, $(oldKeyVariables), $(newKeyVariables)
                                       while @@FETCH_STATUS = 0 begin                                   
                                         insert into $(defaultCatalog)$(defaultSchema)$(prefixName)_data (table_name, event_type, trigger_hist_id, row_data, pk_data, old_data, create_time) 
                                           values('$(targetTableName)','U', $(triggerHistoryId), @DataRow, @OldPk, @OldDataRow, current_timestamp)
                                         insert into $(defaultSchema)$(prefixName)_data_event (node_id, data_id, channel_id, transaction_id)
                                         select c.node_id, @@IDENTITY, '$(channelName)', $(txIdExpression)
                                         from $(defaultCatalog)$(defaultSchema)$(prefixName)_node c, inserted, deleted
                                         where $(varOldPrimaryKeyJoin) and $(varNewPrimaryKeyJoin)
                                         and (c.node_group_id='$(targetGroupId)' and c.sync_enabled=1 and ($(defaultCatalog)dbo.fn_sym_node_disabled() != c.node_id)) $(nodeSelectWhere)
                                         fetch next from DataCursor into @DataRow, @OldPk, @OldDataRow, $(oldKeyVariables), $(newKeyVariables)
                                       end
                                       close DataCursor
                                       deallocate DataCursor
                                    end
                                  end                                  
                                ]]>
                            </value>
                        </entry>
                        <entry key="deleteTriggerTemplate">
                            <value>
                                <![CDATA[
                                create trigger $(triggerName) on $(schemaName)$(tableName) after delete as
                                begin
                                  declare @TransactionId varchar(1000)
                                  declare @OldPk varchar(2000)
                                  $(declareOldKeyVariables)
                                  if (@@TRANCOUNT > 0) begin
                                    execute sp_getbindtoken @TransactionId output;
                                  end
                                  if ($(syncOnIncomingBatchCondition)) begin
                                    declare DataCursor cursor local for
                                      select $(oldKeys), $(oldKeyNames) from deleted where $(syncOnDeleteCondition)
                                      open DataCursor
                                       fetch next from DataCursor into @OldPk, $(oldKeyVariables)
                                       while @@FETCH_STATUS = 0 begin 
                                         insert into $(defaultCatalog)$(defaultSchema)$(prefixName)_data (table_name, event_type, trigger_hist_id, pk_data, create_time) 
                                           values('$(targetTableName)','D', $(triggerHistoryId), @OldPk, current_timestamp)
                                         insert into $(defaultSchema)$(prefixName)_data_event (node_id, data_id, channel_id, transaction_id)
                                         select c.node_id, @@IDENTITY, '$(channelName)', $(txIdExpression)
                                         from $(defaultCatalog)$(defaultSchema)$(prefixName)_node c, deleted
                                         where $(varOldPrimaryKeyJoin)
                                         and (c.node_group_id='$(targetGroupId)' and c.sync_enabled=1 and ($(defaultCatalog)dbo.fn_sym_node_disabled() != c.node_id)) $(nodeSelectWhere)
                                         fetch next from DataCursor into @OldPk, $(oldKeyVariables)
                                       end
                                       close DataCursor
                                       deallocate DataCursor
                                  end
                                end                                   
                                ]]>
                            </value>
                        </entry>
                        <entry key="initialLoadSqlTemplate">
                            <value>
                                <![CDATA[select $(columns) from $(schemaName)$(tableName) t where $(whereClause)]]>
                            </value>
                        </entry>
                    </map>
                </property>
            </bean>
        </property>
    </bean>

</beans>