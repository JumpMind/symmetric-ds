<chapter version="5.0" xml:id="introduction" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:svg="http://www.w3.org/2000/svg" xmlns:ns="http://docbook.org/ns/docbook"
    xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:html="http://www.w3.org/1999/xhtml">
    <title>Introduction</title>  
        <para>This User Guide will introduce both basic and advanced concepts in the configuration
            of SymmetricDS. By the end of this chapter, you will have a better understanding of SymmetricDS' capabilities, and
            many of its basic concepts.</para>
        <section id="definition">
            <title>What is SymmetricDS?</title>
            <para>SymmetricDS is an asynchronous data replication software package that supports multiple subscribers and
                bi-directional synchronization. It uses web and database technologies to replicate tables between relational
                databases, in near real time if desired. The software was designed to scale for a large number of databases, work across
                low-bandwidth connections, and withstand periods of network outage.  The software can be installed as a standalone process, as a web application in a Java application server, or it
                can be embedded into another Java application.</para>
            <para>
                A single installation of SymmetricDS can host multiple engines.  An engine attaches to a single target database
                and is called a <emphasis>node</emphasis>.  The engine is initialized with a few key settings from a properties file. 
                and then synchronization is configured by inserting configuration data into a series of database tables. 
                The engine then creates database triggers on the application tables to be synchronized so that database
                events are captured for delivery to other SymmetricDS nodes.
            </para>
            <para>
                In most databases, the database transaction id is captured by the database triggers so that the insert, update, and delete 
                events can be replicated transactionally via the transport layer to other nodes.  The transport layer uses a CSV protocol over HTTP or HTTPS.
            </para>
            <para>
                SymmetricDS supports synchronization across different database platforms through the concept of <emphasis>dialects</emphasis>. A dialect is 
                an abstraction layer that SymmetricDS uses to insulate the main synchronization
                logic from database-specific implementation details.
            </para>
            <para>
                SymmetricDS is extendable through the use of extension points.  Extension points are custom, Java classes that are
                configured via XML.  Extension points hook into key points in the life-cycle of a synchronization to allow custom 
                behavior to be injected.  Extension points allow custom behavior such as: publishing data to other sources, transforming data,
                and taking different actions based on the content or status of a synchronization.
            </para>
        </section>
        <section>
            <title>SymmetricDS Features</title>
            <para>At a high level, SymmetricDS comes with a number of features that you are likely to need or want when doing data
                synchronization. A majority of these features were created as a direct result of real-world use of SymmetricDS in
                production settings.</para>
       
        <section id="bi-sync">
            <title>Two-Way Table Synchronization</title>
            <para> In practice, much of the data in a typical synchronization requires synchronization in just one direction.
                For example, a retail store sends its sales transactions to a
                central office, and the central office sends its stock items and pricing to the store. Other data may synchronize in both
                directions. For example, the retail store sends the central office an inventory document, and the central office
                updates the document status, which is then sent back to the store. SymmetricDS supports bi-directional or two-way table synchronization
                and avoids getting into update loops by only recording data changes outside of synchronization.</para>
        </section>
        <section id="data-channels">
            <title>Data Channels</title>
            <para> SymmetricDS supports the concept of <emphasis>channels</emphasis> of data.  
                Data synchronization is defined at the table (or table subset) level, and each managed table can be assigned to a
                <emphasis>channel</emphasis> that helps control the flow of data. A channel is a category of data that can be enabled, prioritized and
                synchronized independently of other channels. For example, in a retail environment, users may be waiting for
                inventory documents to update while a promotional sale event updates a large number of items. If processed in
                order, the item updates would delay the inventory updates even though the data is unrelated. By assigning changes to the item
                tables to an <emphasis>item</emphasis> channel and inventory tables' changes to an <emphasis>inventory</emphasis> channel, the changes are
                processed independently so inventory can get through despite the large amount of item data.</para>  Channels are discussed
                in more detail in <xref linkend="choosing-channels"/>.
        </section>
        <section id="notification">
            <title>Change Notification</title>
            <para>
                After a change to the database is recorded, the SymmetricDS nodes interested in the change are notified. Change
                notification is configured to perform either a
                <emphasis>push</emphasis>
                (trickle-back) or a
                <emphasis>pull</emphasis>
                (trickle-poll) of data. When several nodes target their changes to a central node, it is efficient to push the
                changes instead of waiting for the central node to pull from each source node. If the network configuration protects
                a node with a firewall, a pull configuration could allow the node to receive data changes that might otherwise be
                blocked using push. The frequency of the change notification is configurable and defaults to once per minute.
            </para>
        </section>
        <section id="transports">
            <title>HTTP(S) Transport</title>
            <para>
                By default, SymmetricDS uses web-based HTTP or HTTPS in a style called Representation State Transfer (REST).  It is
                lightweight and easy to manage. A series of filters are also provided to enforce authentication and to restrict
                the number of simultaneous synchronization streams. The
                <literal>ITransportManager</literal>
                interface allows other transports to be implemented. 
            </para>
        </section>        
        <section id="plugins">
            <title>Data Filtering and Rerouting</title>
            <para>
                Using SymmetricDS, data can be filtered as it is recorded, extracted, and loaded.
                <itemizedlist>
                    <listitem>
                        <para>
                            Data routing is accomplished by assigning a router type to a  <xref linkend="table_router" xrefstyle="table"/> configuration.
                            Routers are responsible for identifying what target nodes captured changes should be delivered to.  Custom 
                            routers are possible by providing a class implementing <literal>IDataRouter</literal>. 
                        </para>
                    </listitem>
                     <listitem>
                        <para>
                            In addition to synchronization, SymmetricDS is also capable of performing fairly complex transformations (see <xref linkend="transform-data" xrefstyle="select: label"/>) of
                            data as the synchronization data is loaded into a target database.  The transformations can be used to merge source data,
                            make multiple copies of source data across multiple target tables, set defaults in the target tables, etc.  The types of transformation
                            can also be extended to create even more custom transformations. 
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            As data changes are loaded in the target database, a class implementing
                            <xref linkend="extensions-data-loader-filter" xrefstyle="table"/>
                            can change the data in a column or route it somewhere else. One possible use might be to route credit
                            card data to a secure database and blank it out as it loads into a centralized sales database. The
                            filter can also prevent data from reaching the database altogether, effectively replacing the default
                            data loading process.
                        </para>
                    </listitem>                    
                </itemizedlist>
            </para>
        </section>
        <section id="transactions">
            <title>Transaction Awareness</title>
            <para> Many databases provide a unique transaction identifier associated with the rows that are committed together as a transaction.
                SymmetricDS stores the transaction identifier, along with the data that changed, so it can play back the transaction exactly
                as it occurred originally. This means the target database maintains the same transactional integrity as its source. Support for
                transaction identification for supported databases is documented in the appendix of this guide.</para>
        </section>        
        <section id="jmx">
            <title>Remote Management</title>
            <para> Administration functions are exposed through Java Management Extensions (JMX) and can be accessed from the
                Java JConsole or through an application server. Functions include opening registration, reloading data, purging
                old data, and viewing batches. A number of configuration and runtime properties are available to be viewed as
                well.</para>
            <para> SymmetricDS also provides functionality to send SQL events through the same synchronization mechanism that is
                used to send data. The data payload can be any SQL statement. The event is processed and acknowledged just like
                any other event type.</para>
        </section>    
     </section>     
    <section id="requirements">
        <title>System Requirements</title>
        <para> SymmetricDS is written in Java 5 and requires a Java SE Runtime Environment (JRE) or Java SE Development Kit (JDK)
            version 5.0 or above.</para>
        <para> Any database with trigger technology and a JDBC driver has the potential to run SymmetricDS. The database is
            abstracted through a <emphasis>Database Dialect</emphasis> in order to support specific features of each database. The following Database
            Dialects have been included with this release:</para>
        <itemizedlist>
            <listitem>
                <para>MySQL version 5.0.2 and above</para>
            </listitem>
            <listitem>
                <para>Oracle version 8.1.7 and above</para>
            </listitem>
            <listitem>
                <para>PostgreSQL version 8.2.5 and above</para>
            </listitem>
            <listitem>
                <para>Sql Server 2005 and above</para>
            </listitem>
            <listitem>
                <para>HSQLDB 2.x</para>
            </listitem>
            <listitem>
                <para>H2 1.x</para>
            </listitem>
            <listitem>
                <para>Apache Derby 10.3.2.1 and above</para>
            </listitem>
            <listitem>
                <para>IBM DB2 9.5</para>
            </listitem>
            <listitem>
                <para>Firebird 2.0 and above</para>
            </listitem>
            <listitem>
                <para>Interbase 2009 and above</para>
            </listitem>            
        </itemizedlist>
        <para>
            See <xref linkend="databases"/>,          
            for compatibility notes and other details for your specific database.
        </para>        
    </section>
        <section id="background">
            <title>Background</title>
            <para>The idea of SymmetricDS was born from a real-world need. Several of the original developers were, several years
                ago, implementing a commercial Point of Sale (POS) system for a large retailer. The development team came to the
                conclusion that the software available for trickling back transactions to corporate headquarters 
                (frequently known as the 'central office' or 'general office')
                did not meet the
                project needs. The list of project requirements made finding the ideal solution difficult:</para>
            <itemizedlist>
                <listitem>
                    <para> Sending and receiving data with up to 2000 stores during peak holiday loads.</para>
                </listitem>
                <listitem>
                    <para> Supporting one database platform at the store and a different one at the central office.</para>
                </listitem>
                <listitem>
                    <para> Synchronizing some data in one direction, and other data in both directions.</para>
                </listitem>                
                <listitem>
                    <para> Filtering out sensitive data and re-routing it to a protected database.</para>
                </listitem>
                <listitem>
                    <para> Preparing the store database with an initial load of data from the central office.</para>
                </listitem>
            </itemizedlist>
            <para> The team ultimately created a custom solution that met the requirements and led to a successful project. From
                this work came the knowledge and experience that SymmetricDS benefits from today.</para>
        </section>    
        <section>
           <title>Why Database Triggers?</title>
           <para>
             There are several industry recognized techniques to capture changing data for replication, synchronization and integration in a relational database.
           </para>
           <itemizedlist>
           <listitem>
             <para> 
             <emphasis>Lazy data capture</emphasis> queries changed data from a source system using some SQL condition (like a time stamp column).    
             </para>
           </listitem>
           <listitem>
             <para> 
             <emphasis>Trigger-based data capture</emphasis> installs database triggers to capture changes.
             </para>
           </listitem>
           <listitem>
             <para> 
             <emphasis>Log-based data capture</emphasis> reads data changes from proprietary database recovery logs.
             </para>
           </listitem>
           </itemizedlist>
             <para>            
             All three of these techniques have advantages and disadvantages, and all three are on the road map for SymmetricDS. At present time, SymmetricDS supports trigger-based data capture and basic lazy data capture. These two techniques were implemented first for a variety of reasons, not the least of which is that the majority of use cases that SymmetricDS targets can be solved using trigger-based and conditional replication in a way that allows for more database platforms to be supported using industry standard technologies. This fact allowed our developers' valuable time and energy to be invested in designing a product that is easy to install, configure and manage versus spending time reverse engineering proprietary and not well documented database log files.
             </para>
             <para> 
             Trigger-based data capture does introduce a measurable amount of overhead on database operations. The amount of overhead can vary greatly depending on the processing power and configuration of the database platform, and the usage of the database by applications. With nonstop advances in hardware and database technology, trigger-based data capture has become feasible for use cases that involve high data throughput or require scaling out.
             </para>
             <para> 
             Trigger-based data capture is easier to implement and support than log-based solutions. It uses well known database concepts and is very accessible to software and database developers and database administrators. It can usually be installed, configured, and managed by application development teams or database administrators and does not require deployment on the database server itself.
             </para>           
        </section>    
</chapter>